"""Вы поднимаетесь по лестнице. Требуется n шагов, чтобы добраться до вершины.
Каждый раз вы можете подняться на 1 или 2 ступеньки. Сколькими различными способами вы можете подняться на вершину?

Используем метод DP: Dynamic programming и алгоритм обхода бинарного дерева.

Динамическое программирование в теории управления и теории вычислительных систем — способ решения сложных задач путём
разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, выглядящим как набор
перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с
«наивными» методами, можно значительно сократить.

Алгоритм обхода бинарного дерева:
Прямой обход идет в следующем порядке: корень, левый потомок, правый потомок.
Симметричный — левый потомок, корень, правый потомок. Обратный – левый потомок, правый потомок, корень.

Берем за основу прямой обход + Bottom Up DP (считаем шаги снизу вверх)."""


def climbStairs(n: int) -> int:
    one, two = 1, 1  # Значения one и two хранят в себе известное количество шагов для каждой итерации цикла

    for i in range(n - 1):  # В конце мы можем сделать в левом потомке только один шаг, цикл (n - 1). При каждой
        # итерации цикла нам нужно лишь суммировать известное количество шагов на предыдущих двух ступенях
        temp = one  # Временная переменная хранит значение one для дальнейших вычислений
        one = one + two  # Мы уже знаем количество шагов с позиции one и two, делаем итерацию цикла
        two = temp  # В two сохраняем текущее известное количество шагов на данной итерации цикла

    return one  # Значение one собирает в себе все возможные варианты количества шагов


n1 = 1
print(climbStairs(n1))
n2 = 3
print(climbStairs(n2))
n3 = 5
print(climbStairs(n3))
